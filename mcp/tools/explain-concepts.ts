/**
 * clay_explain_concepts tool - Explain Clay concepts, capabilities, and best practices
 * 
 * This tool provides comprehensive documentation to help LLMs understand how to:
 * - Create generators from scratch
 * - Write models effectively
 * - Use template context variables (clay_key, clay_parent, etc.)
 * - Leverage all available features
 */

import { validateInput } from '../shared/validation.js';
import {
  ExplainConceptsInput,
  ExplainConceptsInputSchema,
} from '../shared/schemas.js';

/**
 * Comprehensive Clay documentation for LLMs
 */
const concepts = {
  overview: {
    title: 'Clay Overview',
    content: `Clay is a template-focused code generator that transforms JSON models into code using Handlebars templates.

**Core Components:**
1. Models (model.json) - Define your domain structure
2. Generators (generator.json) - Define transformation steps
3. Templates - Handlebars files that generate code
4. .clay file - Tracks generated files for regeneration and cleanup

**Workflow:**
1. Create a model.json describing your domain
2. Reference generators in the model
3. Generators execute steps (generate templates, run commands, copy files)
4. Clay tracks everything in .clay file for easy regeneration/cleanup`
  },

  models: {
    title: 'Creating Models',
    content: `Models are JSON files that describe your domain structure.

**Basic Structure:**
\`\`\`json
{
  "name": "myproject",
  "generators": ["backend", "frontend"],
  "model": {
    "types": [
      {
        "name": "User",
        "fields": [
          { "name": "email", "type": "string" },
          { "name": "age", "type": "number" }
        ],
        "commands": [
          {
            "name": "createUser",
            "parameters": [
              { "name": "email", "type": "string" }
            ]
          }
        ]
      }
    ]
  }
}
\`\`\`

**Special Properties:**

1. **include** - Split models across files:
   \`\`\`json
   {
     "model": {
       "events": [
         { "include": "events/user-events.json" }
       ]
     }
   }
   \`\`\`

2. **mixin** - Apply functions to transform model parts:
   \`\`\`json
   {
     "model": {
       "types": [
         {
           "name": "User",
           "mixin": ["has_timestamps.js", "has_audit_fields.js"]
         }
       ]
     }
   }
   \`\`\`

**Best Practices:**
- Use clear, descriptive property names
- Structure models to match your intended output
- Use mixins for common patterns (timestamps, audit fields, etc.)
- Split large models using includes
- Keep models focused on domain structure, not implementation`
  },

  generators: {
    title: 'Creating Generators',
    content: `Generators define the steps to transform models into code.

**generator.json Structure:**
\`\`\`json
{
  "partials": ["header.hbs", "footer.hbs"],
  "formatters": ["clay-generator-formatter-prettier"],
  "steps": [
    {
      "generate": "templates/{{pascalCase name}}.java",
      "select": "$.model.types[*]",
      "target": "src/main/java/{{pascalCase name}}.java"
    },
    {
      "copy": "foundation/",
      "target": "src/foundation/"
    },
    {
      "runCommand": "npm install",
      "npxCommand": false
    }
  ]
}
\`\`\`

**Step Types:**

1. **Generate from Template:**
   \`\`\`json
   {
     "generate": "templates/controller.ts",
     "select": "$.model.types[*]",
     "target": "controllers/{{kebabCase name}}.controller.ts",
     "touch": false
   }
   \`\`\`
   - \`generate\`: Path to Handlebars template
   - \`select\`: JSONPath to filter model (optional)
   - \`target\`: Output path (supports Handlebars)
   - \`touch\`: If true, only create if file doesn't exist

2. **Copy Files:**
   \`\`\`json
   {
     "copy": "foundation/base-class.ts",
     "select": "$.model.types[*]",
     "target": "{{kebabCase name}}/base.ts"
   }
   \`\`\`

3. **Run Commands:**
   \`\`\`json
   {
     "runCommand": "npm install {{name}}",
     "select": "$.model.dependencies[*]",
     "npxCommand": false
   }
   \`\`\`

**Partials:**
Reusable template fragments:
\`\`\`handlebars
{{!-- partials/header.hbs --}}
/**
 * Generated by Clay
 * Model: {{clay_model.name}}
 * Date: {{currentDate}}
 */
\`\`\`

Use in templates: \`{{>header}}\`

**Formatters:**
External tools to format generated code (e.g., prettier, eslint --fix)`
  },

  templates: {
    title: 'Writing Templates',
    content: `Templates use Handlebars syntax with 47+ helpers.

**Basic Template:**
\`\`\`handlebars
{{>header}}

export class {{pascalCase name}} {
  {{#each fields}}
  private {{camelCase name}}: {{type}};
  {{/each}}

  constructor(
    {{#each fields}}
    {{camelCase name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {
    {{#each fields}}
    this.{{camelCase name}} = {{camelCase name}};
    {{/each}}
  }

  {{#each commands}}
  {{camelCase name}}(
    {{#each parameters}}
    {{camelCase name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ): void {
    // Implementation for {{name}}
  }
  {{/each}}
}
\`\`\`

**File Paths as Templates:**
Paths support Handlebars:
\`\`\`
templates/{{pascalCase name}}Controller.ts
output/{{kebabCase name}}/{{snakeCase name}}.model.ts
\`\`\`

**Common Helpers:**
- Casing: \`pascalCase\`, \`camelCase\`, \`kebabCase\`, \`snakeCase\`, \`startCase\`
- String: \`pluralize\`, \`singularize\`, \`capitalize\`, \`upperCase\`, \`lowerCase\`
- Logic: \`if\`, \`unless\`, \`eq\`, \`ne\`, \`gt\`, \`lt\`, \`and\`, \`or\`, \`switch/case\`
- Iteration: \`each\`, \`eachUnique\`, \`eachUniqueJSONPath\`, \`times\`, \`group\`
- Utility: \`json\`, \`markdown\`, \`inc\`, \`propertyExists\`

Use \`clay_list_helpers\` tool to get complete list with examples.`
  },

  'context-variables': {
    title: 'Template Context Variables (Hidden Capabilities)',
    content: `Clay automatically adds special variables to template contexts when using JSONPath selectors.

**Available Context Variables:**

1. **clay_model** - Complete root model
   \`\`\`handlebars
   {{!-- Access root model from anywhere --}}
   Project: {{clay_model.name}}
   Total types: {{clay_model.model.types.length}}
   
   {{!-- Cross-reference other parts of the model --}}
   {{#each clay_model.model.types}}
     {{#if (eq ../name this.relatedType)}}
       Found related type: {{this.name}}
     {{/if}}
   {{/each}}
   \`\`\`

2. **clay_parent** - Parent element in JSON structure
   \`\`\`handlebars
   {{!-- Current field --}}
   Field: {{name}}
   
   {{!-- Parent type --}}
   Type: {{clay_parent.name}}
   
   {{!-- Grandparent (navigate up multiple levels) --}}
   Model: {{clay_parent.clay_parent.name}}
   
   {{!-- Parent's JSONPath --}}
   Parent path: {{clay_parent.json_path}}
   \`\`\`

3. **clay_key** - JSON property name of current element
   \`\`\`handlebars
   {{!-- If iterating over object properties --}}
   Property name: {{clay_key}}
   Property value: {{this}}
   \`\`\`

4. **clay_json_key** - Alternative to clay_key
   \`\`\`handlebars
   Key: {{clay_json_key}}
   \`\`\`

**Practical Example:**

Model:
\`\`\`json
{
  "name": "UserService",
  "model": {
    "types": [
      {
        "name": "User",
        "category": "entity",
        "commands": [
          {
            "name": "createUser",
            "raises": "UserCreated"
          }
        ]
      }
    ]
  }
}
\`\`\`

Generator step with JSONPath \`$.model.types[*].commands[*]\`:
\`\`\`handlebars
// Command: {{name}}
// Type: {{clay_parent.name}}
// Category: {{clay_parent.category}}
// Service: {{clay_model.name}}
// Event: {{raises}}

export function {{camelCase name}}Handler() {
  // Handler for {{clay_parent.name}}.{{name}}
  // Raises: {{raises}}
  // Service: {{clay_model.name}}
}
\`\`\`

Output:
\`\`\`typescript
// Command: createUser
// Type: User
// Category: entity
// Service: UserService
// Event: UserCreated

export function createUserHandler() {
  // Handler for User.createUser
  // Raises: UserCreated
  // Service: UserService
}
\`\`\`

**When to Use Each:**

- **clay_model**: Cross-references, lookups, global metadata
- **clay_parent**: Access parent properties, understand context hierarchy
- **clay_key**: When iterating over object properties (not arrays)
- **Standard context**: Current selected element's properties

**Important Notes:**
- These variables are automatically injected when using JSONPath \`select\`
- They provide powerful navigation capabilities without manual passing
- They enable templates to be context-aware and make intelligent decisions
- Use them to avoid hardcoding and enable dynamic template behavior`
  },

  jsonpath: {
    title: 'JSONPath Selectors',
    content: `JSONPath expressions select parts of the model for processing.

**Syntax:**

- \`$\` - Root element
- \`.\` - Child property
- \`[*]\` - All array elements
- \`[?(@.property == 'value')]\` - Filter
- \`..\` - Recursive descent

**Common Patterns:**

\`\`\`javascript
// All types
"$.model.types[*]"

// All fields in all types
"$.model.types[*].fields[*]"

// All commands across all types
"$.model.types[*].commands[*]"

// All parameters in all commands
"$.model.types[*].commands[*].parameters[*]"

// Filter: only string type parameters
"$.model.types[*].commands[*].parameters[?(@.type == 'string')]"

// Filter: only types with category 'entity'
"$.model.types[?(@.category == 'entity')]"

// Filter: commands that raise events
"$.model.types[*].commands[?(@.raises)]"

// Get all unique categories (use with eachUniqueJSONPath)
"$.model.types[*].category"
\`\`\`

**Testing JSONPath:**
Use \`clay_test_path\` tool to verify expressions:
\`\`\`javascript
clay_test_path({
  model_path: "./model.json",
  json_path: "$.model.types[?(@.category == 'entity')]"
})
\`\`\`

**In Generator Steps:**
\`\`\`json
{
  "generate": "templates/entity.ts",
  "select": "$.model.types[?(@.category == 'entity')]",
  "target": "entities/{{kebabCase name}}.entity.ts"
}
\`\`\`

This runs the template once for each matching element.`
  },

  mixins: {
    title: 'Mixins - Model Transformations',
    content: `Mixins are JavaScript functions that transform parts of the model.

**Use Cases:**
- Add conventional fields (timestamps, audit fields)
- Calculate derived properties
- Inject common patterns
- Transform model structure

**Example Mixin:**
\`\`\`javascript
// mixins/has_timestamps.js
module.exports = function(modelPart) {
  // Add timestamp fields if not present
  if (!modelPart.fields) {
    modelPart.fields = [];
  }
  
  modelPart.fields.push(
    { name: 'createdAt', type: 'Date', readonly: true },
    { name: 'updatedAt', type: 'Date', readonly: true }
  );
  
  return modelPart;
};
\`\`\`

**Using in Models:**
\`\`\`json
{
  "model": {
    "types": [
      {
        "name": "User",
        "mixin": ["has_timestamps.js"],
        "fields": [
          { "name": "email", "type": "string" }
        ]
      }
    ]
  }
}
\`\`\`

After mixin execution, User type will have email, createdAt, and updatedAt fields.

**Advanced Mixin:**
\`\`\`javascript
// mixins/add_crud_commands.js
module.exports = function(type) {
  type.commands = type.commands || [];
  
  const entityName = type.name;
  
  type.commands.push(
    {
      name: \`create\${entityName}\`,
      parameters: type.fields.filter(f => !f.readonly),
      raises: \`\${entityName}Created\`
    },
    {
      name: \`update\${entityName}\`,
      parameters: [
        { name: 'id', type: 'string' },
        ...type.fields.filter(f => !f.readonly)
      ],
      raises: \`\${entityName}Updated\`
    },
    {
      name: \`delete\${entityName}\`,
      parameters: [{ name: 'id', type: 'string' }],
      raises: \`\${entityName}Deleted\`
    }
  );
  
  return type;
};
\`\`\`

This mixin automatically generates CRUD commands based on the type's fields.

**Best Practices:**
- Keep mixins focused on a single concern
- Make mixins reusable across projects
- Document what each mixin does
- Test mixins with different model structures
- Use mixins to enforce conventions`
  }
};

/**
 * Get comprehensive Clay documentation
 */
export async function explainConcepts(input: ExplainConceptsInput) {
  const topic = input.topic || 'overview';
  const includeExamples = input.include_examples;

  if (topic === 'all') {
    // Return all concepts
    return {
      success: true,
      concepts: Object.entries(concepts).map(([key, value]) => ({
        topic: key,
        ...value
      })),
      available_topics: Object.keys(concepts),
      note: 'This provides comprehensive documentation for creating generators and models. Use specific topics for focused information.'
    };
  }

  const concept = concepts[topic as keyof typeof concepts];
  if (!concept) {
    return {
      success: false,
      message: `Unknown topic: ${topic}`,
      available_topics: Object.keys(concepts)
    };
  }

  return {
    success: true,
    topic,
    ...concept,
    available_topics: Object.keys(concepts),
    related_tools: getRelatedTools(topic)
  };
}

/**
 * Get related MCP tools for a topic
 */
function getRelatedTools(topic: string): string[] {
  const toolMap: Record<string, string[]> = {
    overview: ['clay_init', 'clay_generate', 'clay_get_model_structure'],
    models: ['clay_get_model_structure', 'clay_test_path', 'clay_init'],
    generators: ['clay_list_generators', 'clay_init'],
    templates: ['clay_list_helpers', 'clay_test_path'],
    'context-variables': ['clay_test_path', 'clay_get_model_structure'],
    jsonpath: ['clay_test_path'],
    mixins: ['clay_get_model_structure']
  };

  return toolMap[topic] || [];
}

/**
 * MCP tool handler
 */
export async function explainConceptsTool(args: unknown) {
  const validation = validateInput(ExplainConceptsInputSchema, args);
  if (!validation.success) {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({
            success: false,
            message: validation.error
          }, null, 2)
        }
      ]
    };
  }

  const input = {
    ...validation.data,
    include_examples: validation.data.include_examples ?? true
  };
  
  const result = await explainConcepts(input);

  return {
    content: [
      {
        type: 'text',
        text: JSON.stringify(result, null, 2)
      }
    ]
  };
}
